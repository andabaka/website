---
title: Market Basket
author: Marijana Andabaka
date: '2023-04-03'
slug: []
categories: []
tags: []
draft: false
excerpt: "Machine learning i sustav preporuka. Collaborative filtering, Association Rules i Item Popularity algoritmi u primjeni analize potrošačke košarice. "
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
    eval       = TRUE,
    warning    = FALSE,
    message    = FALSE
    )
```

```{r pressure, echo=FALSE}
knitr::include_graphics("img/img1.jpg")
```


## UVOD  

Analiza potrošačke košarice (engl. __*Market Basket Analysis*__, *Affinity Analysis*) je proces razumijevanja obrasca ponašanja pri kupnji i povezanosti između različitih artikala. Cilj je pronaći artikle koji se pojavljuju zajedno u transakcijama što omogućuje primjenu ciljnih strategija poput raspodjele artikala unutar trgovina, davanje popusta na artikle koji se često prodaju zajedno te kreiranja preporuka proizvoda s ciljem privlačenja kupaca i povećanja potrošnje. Postoji nekoliko metoda analize potrošačke košarice^[https://university.business-science.io/courses/]:

- __Kolaborativno filtriranje__ (engl. *Collaborative Filtering*)
- __Pravila pridruživanja__ (engl. *Association Rules*)
- __Popularni artikli__ (engl. *Item Popularity*)
- __Kontekstno bazirani sustavi za preporuke__ (engl. *Content-Based-Filtering*)
- __Hibridni modeli__

Nešto više o metodama koje ćemo koristiti u ovom projektu: 

1. __Kolaborativno filtriranje__ temelji se na sličnostima korisnika ili proizvoda koje se računaju putem unaprijed definirane funkcije sličnosti (engl. *similarity function*). Funkcija sličnosti numerički određuje udaljenost (npr. euklidska udaljenost, Pearson korelacija, kosinus udaljenost) između dva korisnika ili proizvoda u svrhu definiranja onih koji su najbliži. <br/> Sustavi orijentirani prema korisniku (engl. *user-based collaborative         filtering*) pronalaze slične korisnike za određenog promatranog korisnika te se temelje na pretpostavci da slični korisnici preferiraju slične proizvode. <br/> Sustavi orijentirani prema proizvodima (engl. *item-based collaborative filtering*) pronalaze slične proizvode za određeni promatrani proizvod te se temelje na pretpostavci da slične proizvode preferiraju slični korisnici.

2. Metoda __pravila pridruživanja__ jedna je od najčešće korištenih metoda u analiziranju potrošačke košarice ili transakcijskih podataka. Cilj je otkriti specifične uzorke ili pravila unutar skupa promatranih podataka na temelju koncepta strogih pravila. Pravila između dva kupljena proizvoda nastaju pomoću tri veličine: 
- značaj (engl. *support*) je vjerojatnost da se dvije stavke istovremeno pojavljuju $${P(stavka1,stavka2)}$$
- pouzdanost (engl. *confidence*) predstavlja značaj podijeljen sa vjerojatnošću kupnje druge stavke $$\frac{značaj}{P(stavka2)}$$
- poboljšanje (engl. *lift*) je pouzdanost podijeljenja sa vjerojatnošću kupnje prve stavke $$\frac{pouzdanost}{P(stavka1)}$$ <br/> Kad se ove veličine kombiniraju, stavke sa najvećom vjerojatnošću kupnje su one koje imaju najveće poboljšanje. Metoda se odlikuje brzinom i dobrim funkcioniranjem kod analize predmeta koji se najčešće kupuju. 

3. Strategija primjene metode __popularni artikli__ je vrlo jednostavna. Artikli se razvrstavaju na temelju učestalosti kupnje (tj. popularnosti) u svrhu razumijevanja potrošačkih navika. Sustav preporuka se temelji samo na najčešće kupljenim artiklima koji se trenutno ne kupuju. Loše strana ovog pristupa je njegova jednostavnost i nedostatak nekih temeljnih sličnosti unutar segmenata ili skupina kupaca. 


## ANALIZA

U ovom projektu napravit ćemo nekoliko modela pomoću kolaborativnog filtriranja, pravila pridruživanja i popularnosti artikala unutar `recommenderlab` paketa.^[https://cran.r-project.org/web/packages/recommenderlab/recommenderlab.pdf] `recommenderlab` paket omogućuje procjenu i usporedbu različitih algoritama te brzu procjenu modela sa najboljim performansama.

### Učitavanje paketa

Za provedbu projekta učitani su potrebni paketi: `recommenderlab`, `tidyverse`, `tidyquant`, `knitr`, `glue`, `DT`

```{r}
library(recommenderlab) 
library(tidyverse) 
library(tidyquant)
library(knitr)
library(glue)
library(DT) 
```

### Baza podataka

Podaci pripadaju pekarnici __The Bread Basket__^[https://www.kaggle.com/datasets/mittalvasu95/the-bread-basket] koja se nalazi u Edinburghu te sadrži online transakcije kupaca u vremenskom periodu od 26.01.2011. do 27.12.2013. Baza ima 20.507 unosa, preko 90.000 transakcija i 5 stupaca (obilježja).

Obilježja: 

- __TransactionNo__: jedinstveni broj transakcije
- __Items__: naziv kupljenog artikla
- __DateTime__: datum i vrijeme transakcije
- __Daypart__: dio dana kad je transakcija izvršena (jutro, popodne, večer, noć)
- __DayType__: da li je transakcija izvršena vikendom ili radnim danima

```{r}
# Unos baze podataka
data_bakery <- read.csv("Data/Bakery.csv")
datatable(data_bakery, caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: center;',
    'Tablica 1: ', htmltools::em('Interaktivna baza provedenih transakcija ')))
```

## CRISP-DM metodologija 

Proces provedbe projekta temelji se na CRISP-DM metodologiji (engl. *CRoss Industry Standard Process for Data Mining*)^[https://www.ibm.com/docs/it/spss-modeler/saas?topic=dm-crisp-help-overview]. Kroz CRISP-DM model podaci se dubinski analiziraju kao iterativan proces koji se sastoji od 6 faza (Slika 1).    

```{r, echo=FALSE}
knitr::include_graphics("img/crisp-dm.png")
```


### Razumijevanje problema (*Business Understanding*)

Problem koji se želi riješiti je taj da organizacija potencijalno može ostvariti veću zaradu na način da preporučuje određene proizvode određenim kupcima. Kupci uglavnom odlaze u trgovinu ili posjećuju web stranice iz određenih razloga što predstavlja glavnu priliku za povećanje prodaje preporukom proizvoda o kojima kupac možda i ne razmišlja. To mogu biti slični proizvodi koje su kupci kupili ili proizvodi koji su kupljeni sa sličnim artiklima.

### Razumijevanje podataka (*Data Understanding*)

Prvo ćemo pogledati koliko se često pojedini artikli kupuju te odrediti popularne artikle.

```{r}
# Pogled na podatke
data_bakery %>% glimpse()

# Formatiranje varijabli datum, vrijeme i dio dana
data_bakery_tbl <- data_bakery %>% 
  mutate(Date = as.Date(DateTime),
         Time = format(as.POSIXct(DateTime), format = "%H:%M:%S"),
         Daypart = as.factor(Daypart))
  
# Provjera da li baza sadrži nedostajuće vrijednosti
data_bakery_tbl %>%  summarise_all(~sum(is.na(.)))

# Frekvencije prodanih artikala
data_bakery_freq <- data_bakery_tbl %>% 
  count(Items) %>% 
  arrange(desc(n)) %>% 
  mutate(pct = n/sum(n),
         cum_pct = cumsum(pct)) 
  
```

Varijablu *DateTime* smo stavili u odgovarajući format te odvojili datum i vrijeme u dva zasebna obilježja i utvrdili da ne postoje nedostajuće vrijednosti. Najprodavaniji artikl je kava sa 27% od ukupnog broja prodanih proizvoda. Uz kavu, kruh i čaj zajedno čine 50% ukupne prodaje. U grafu ćemo vizualizirati top 10 artikala.

```{r}
# 10 najpopularnijih artikala
data_bakery_freq %>% 
  top_n(10, wt = n) %>% 
  ggplot(aes(x = reorder(Items,n), y = n)) +
  geom_bar(stat = "identity", fill = "#5b0b15") +
  labs(title = "10 najpopularnijih artikala", x= "", y = "Broj prodanih artikala") +
  theme_tq() +
  scale_color_tq() +
  coord_flip() +
  scale_y_continuous(n.breaks = 6)
```

Na grafu možemo vidjeti da se u top 10 najprodavanijih artikala nalaze kava, kruh, čaj, kolač, pecivo, sendvić, medialunas (argentinsko pecivo), vruća čokolada, keksi i brownie.

U niže navedenim grafovima prikazane su ostale zanimljive činjenice.

```{r}
# Broj narudžbi u odnosu na dio dana
data_bakery_tbl %>% 
  ggplot(aes(Daypart)) +
  geom_histogram(stat = "count", fill = "#5b0b15") +
  theme_tq() +
  labs(title = "Frekvencija narudžbi s obzirom na dio dana",
        y    = "",
        x    = "Dio dana")
```

```{r}
# Narudžbe prema danima u tjednu
data_bakery_tbl %>% 
  ggplot(aes(wday(Date,
                  week_start = getOption("lubridate.week.start", 1)))) +
  geom_histogram(stat = "count", fill = "#5b0b15") +
  scale_x_continuous(breaks = c(1,2,3,4,5,6,7),
                     labels = c("Pon", "Uto", "Sri", "Čet", "Pet", "Sub", "Ned")) + theme_tq() +
  labs(title = "Narudžbe prema danima u tjednu",
       y     = "",
       x     = "")
```

```{r}
# Narudžbe prema satima u danu
data_bakery_tbl %>% 
  ggplot(aes(hour(hms(Time)))) +
  geom_histogram(stat = "count", fill = "#5b0b15") +
  theme_tq() +
  labs(title = "Narudžbe prema satima u danu",
       y     = "",
       x     = "Sati u danu")
  
```

Najveći broj narudžbi ostvaruje se poslijepodne i ujutro vikendima, najviše subotom između 10.00 i 14.00 sati.

### Priprema podataka (*Data Preparation*)

Podatke ćemo formatirati u 2x2 matricu u kojoj se narudžbe nalaze u redovima, a proizvodi u stupcima. Ovaj format se naziva *user-item* matrica zato jer se korisnici (kupci ili narudžbe) nalaze u redovima, a stavke (proizvodi) u stupcima. Zatim matricu pretvaramo u "matricu ocjena" (engl. *binaryRatingMatrix*). Ovaj tip matrice potreban je za analizu,  a normalizacija podataka nije potrebna je binarna matrica ocjena označava da li je ili nije proizvod kupljen sa 1 i 0.

Prije kreiranja matrice, provjerit ćemo da li narudžbe sadrže isti proizvod više od jednom.

```{r}
# Filtriranje po broju narudžbe i artiklu
data_bakery_tbl %>% 
  filter(TransactionNo == 2 & Items == "Scandinavian") %>% 
  select(TransactionNo, Items)
```

Možemo vidjeti da pojedine narudžbe sadrže iste artikle više puta. Duplikate ćemo obrisati jer nas zanima samo da li je pojedini artikl naručen ili nije. 

```{r}
# Kreiranje jedinstvenog identifikatora istih artikala na istoj narudžbi
data_bakery_tbl <- data_bakery_tbl %>% 
# Brisanje duplikata i identifikatora  
  mutate(TranNo_Item = paste(TransactionNo, Items, sep = ' ')) %>% 
  distinct(TranNo_Item, .keep_all = TRUE) %>% 
  select(-TranNo_Item)
```

Sada možemo pristupiti izradi *user-item* matrice za koju ćemo odabrati potrebne varijable (broj narudžbe i artikle) te ju formatiramo u binarnu matricu ocjena i uklanjamo broj transakcija koji nam više nije potreban.

```{r}
ratings_matrix <- data_bakery_tbl %>% 
  select(TransactionNo, Items) %>% 
  mutate(value = 1) %>% 
  spread(Items, value, fill = 0) %>% 
  select(-TransactionNo) %>% 
  as.matrix() %>% 
  as("binaryRatingMatrix")
```

### Modeliranje (*Data Modeling*)

#### Trening/test podjela

`recommenderlab`^[https://cran.r-project.org/web/packages/recommenderlab/vignettes/recommenderlab.pdf] paket omogućava procjenu i usporedbu različitih algoritama te brzo određivanje najprikladnijeg pristupa. Kako bi se uspostavila učinkovitost modela, podatke ćemo podijeliti u skupove za treniranje i testiranje postavljanjem train = 0.8 za 80/20 treniranje/testiranje. Zatim odabiremo  method = "cross" i k = 5 za 5-fold kros-validaciju. Ovo znači da se podaci dijele u *k* podskupove pri čemu se 80% podataka koristi za treniranje, a preostalih 20% za testiranje. Modeli se rekurzivno procjenjuju 10 puta, a svaki put koristeći različitu trening/test podjelu što osigurava da se svi proizvodi uzmu u obzir za treniranje i testiranje. Zatim se izračunava prosjek rezultata kako bi se dobio jedan skup za procjenu. Zadana postavka given = -1 znači da će se sve stavke osim jedne koristiti za učenje, a preostala stavka će se koristiti za evaluaciju.

```{r}
eval_scheme <- ratings_matrix %>% 
  evaluationScheme(method = "cross",
                   train  = 0.8,
                   k      = 5,
                   given  = -1)
eval_scheme
```

#### Algoritmi

```{r}
list_algorithms <- list(
  "random items"      = list(name = "RANDOM",
                        param = NULL),
  "popular items"     = list(name = "POPULAR",
                        param = NULL),
  "user-based CF"     = list(name = "UBCF",
                        param = list(method = "Cosine", nn = 500)),
  "item-based CF"     = list(name = "IBCF",
                        param = list(k = 5)),
  "association rules" = list(name = "AR",
                        param = list(supp = 0.01, conf = 0.01))
)
```

#### Procjena algoritama

Algoritme ćemo analizirati pomoću funkcije evaluate() specificirajući type = "topNList" za procjenu Top N Liste preporuka proizvoda i n = 1:10 za procjenu točnosti od 1 do 10 preporuka.

```{r}
results <- recommenderlab::evaluate(
  eval_scheme,
  list_algorithms,
  type  = "topNList",
  n     = 1:10)
```

#### Procjena modela
 
Rezultat je lista koja sadrži 5 evaluacija. Svaki model se može istražiti pomoću `getConfusionMatrix()` funkcije koja prikazuje listu sa matricom. U nastavku je prikazan primjer za "random items" model.

```{r}
results

cf_matrix_model <-results$`random items` %>% 
  getConfusionMatrix() %>% 
  as.list()

# Izračun prosječne vrijednosti 5-fold kros validacije i odabir potrebnih stupaca
as.data.frame(Reduce("+", cf_matrix_model) / length(cf_matrix_model)) %>% 
  select("n", "precision", "recall", "TPR", "FPR")
```

Prethodne korake pretvorit ćemo u funkciju i primijenit ju na sve elemente u listi. Zatim koristimo funkciju `map()` za iteraciju funkcije kroz sve modele te `enframe()` i `unnest()` za dobivanje rezultata u jednoj razini kako bismo mogli usporediti modele.

```{r}
# Funkcija
avg_confusion_matrix <- function(results) {
    cf_matrix_model <- results %>%
        getConfusionMatrix() %>%
         as.list()
as.data.frame(Reduce("+", cf_matrix_model) / length(cf_matrix_model)) %>% 
  select("n", "precision", "recall", "TPR", "FPR")
}

# Iteracija fukcije kroz sve modele
results_tbl <- results %>% 
  map(avg_confusion_matrix) %>% 
  enframe() %>% 
  unnest()

results_tbl
```

#### Vizualizacija performansi modela

Performanse modela ćemo usporediti pomoću krivulje operativne karakteristike prijemnika ili __ROC krivulje__. Klasifikacijski modeli se obično uspoređuju sa ROC (engl. *Receiver operating characteristic*) grafom koji prikazuje stvarno pozitivnu stopu (engl. *true positive rate*, TPR) u odnosu na lažno pozitivnu stopu (engl. *false positive rate*, FPR). TPR je smješten na osi y, FPR na osi x, a što je veća površina ispod ROC krivulje, model pokazuje bolje performanse u odnosu na ostale. Pomoću funkcije `fct_reorder2()` posložit ćemo modele po najboljim FPR i TPR vrijednostima.  

```{r}
results_tbl %>% 
  ggplot(aes(FPR, TPR,
             colour = fct_reorder2(as.factor(name), FPR, TPR))) +
  geom_line() +
  geom_label(aes(label = n)) +
  theme_tq() +
  scale_color_tq() + 
  theme(legend.position = "right",
        legend.direction = "vertical") +
  labs(title = "ROC krivulja",
       subtitle = "Najbolji model: Popular Items (Popularne stavke)",
       color = "Model")
```

Model *popular items* pokazao se kao najbolji jer postiže najviši TPR za bilo koju razinu FPR-a, odnosno model proizvodi najveći broj relevantnih preporuka (*true positives*) za istu razinu nerelevantnih preporuka (*false positives*). 

Performanse modela možemo usporediti i sa __PR krivuljom__ (odnos odziva i preciznosti, engl. *Precision-Recall curve*). Preciznost pokazuje koliko su modeli osjetljivi na lažno pozitivne (tj. model predlaže artikle za koje nije vjerojatno da će biti kupljeni) dok odziv (drugi naziv za TPR) pokazuje koliko su modeli osjetljivi na lažno negativne (tj. model ne predlaže artikl za koji postoji velika vjerojatnost da će biti kupljen). U konačnici cilj je točno predviditi artikle koji će vrlo vjerojatno biti kupljeni jer bi to imalo pozitivan utjecaj na prodaju i prihode. Odnosno, želimo povećati odziv (ili smanjiti lažno negativne) za istu razinu preciznosti.

```{r}
results_tbl %>% 
  ggplot(aes(recall, precision,
             color = fct_reorder2(as.factor(name), recall, precision))) +
  geom_line() +
  geom_label(aes(label = n)) +
  theme_tq() +
  scale_color_tq() +
  theme(legend.position = "right",
        legend.direction = "vertical") +
  labs( title = "Preciznost i Odziv (Precision Vs Recall",
        subtitle = "Najbolji model: Popular Items (Popularne stavke)",
        color = "Model")
```

Graf preciznosti i odziva potvrđuje da je *popular items* najbolji model što znači da minimizira lažno negativne za sve razine lažno pozitivnih preporuka.

### Generiranje predikcija 

Nakon što smo saznali koji model ima najbolje performanse, možemo pristupiti testiranju predikcija, a za to nam je potrebna nova hipotetska narudžba. Napravit ćemo narudžbu koja sadrži džem, mineralnu vodu i kruh (engl. *Jam*, *Mineral Water*, *Bread*) te ju staviti u odgovarajući format koji `recommenderlab` koristi te na kraju našu izmišljenu narudžbu proslijeđujemo u funkciju za predviđanje.

Prvo formatiramo recommender sa postavkama najboljeg modela i stvaramo novu narudžbu.

```{r}
# Recommender
train_recLab <- getData(eval_scheme, "train")

fit_PopularItm<- recommenderlab::Recommender(
  train_recLab,
  method = "POPULAR",
  param = NULL)

fit_PopularItm

# Hipotetska narudžba
new_order <- c("Jam", "Mineral Water", "Bread")
```

Prije nego što napravimo predikciju, narudžbu ćemo pretvoriti u binarnu matricu ocjena s nazivima stupaca koji odgovaraju trening setu podataka te jedinicama i nulama za prisutnost ili odsutnost stavke u narudžbi.

```{r}
# Izvlačenje naziva stupaca iz trening seta podataka
items_names <- train_recLab@data %>% colnames()

# Stvaranje matrice nove narudžbe
new_order_matrix <- tibble(
  item = items_names) %>% 
  mutate(value = as.numeric(item %in%new_order)) %>% 
  spread(key = item, value = value) %>% 
  as.matrix() %>% 
  as("binaryRatingMatrix")

```

Sada možemo koristit `predict()` funkciju u koju unosimo recommender, novu narudžbu i broj predviđanja koja želimo napraviti.

```{r}
prediction <- predict(fit_PopularItm, 
                newdata = new_order_matrix, 
                n       = 5)

as(prediction, "list")
```

Predikcija generira rezultat preporučenih 5 proizvoda, a to su: kava, čaj, kolač, pecivo i sendvić.


## EVALUACIJA (*Evaluation*)
 
Evidentno je da uz minimalne troškove revidiranja poslovnih strategija istovremeno postoji potencijal za povećanje prodaje i usluge. Kupci bi mogli dobiti bolju uslugu jer bi opcije kupnje bile prilagođene njihovim potrebama.



